/*
 * This Source Code Form is subject to the terms
 * of the *GNU GENERAL PUBLIC LICENSE Version 3*.
 *
 * Authors:
 *  - 2018, Annika Ofenloch (DLR RY-AVS)
 */

#include "router.h"

/*
 * Arbitrates between outputs, polls different inputs and sends the flits if there are free 
 * resources in the desired output. Uses round-robin arbitration (with dynamic prioritization 
 * and fairness, avoiding starvation). N->E->W->S->L (circular) prioritization of the requests 
 * from inputs (from LBDR modules) are checked. This function should be called every cycle.
 * 
 * Returns
 * 	True if flit was sent, false if the flit was not sent.
 */
bool Router::arbitrateWithRoundRobinPrioritization() {

	if (!validGrantSignal(mReq_N_LBDR, mFlits_RX_N, "Credit_in_N++")) {
		if (!validGrantSignal(mReq_E_LBDR, mFlits_RX_E, "Credit_in_E++")) {
			if (!validGrantSignal(mReq_W_LBDR, mFlits_RX_W, "Credit_in_W++")) {
				if (!validGrantSignal(mReq_S_LBDR, mFlits_RX_S,
						"Credit_in_S++")) {
					if (!validGrantSignal(mReq_L_LBDR, mFlits_RX_L,
							"Credit_in_L++")) {
						return false;
					}
				}
			}
		}
	}

	return true;
}

/*
 * Tries to send a flit to the direction pointed by request. In case a header flit is received,
 * send the corresponding request is generated, a tail flit resets the request, else a flit will
 * sent to the direction of the request generated by the previous header flit.
 * 
 * Parameters:
 * 	Router::Request& request: A reference to the enum containing requests for the current direction
 * 	std::queue<uint32_t>& flitFIFO: Reference to the FIFO input buffer used for the current direction
 * 	std::string creditString: a string representing the current credit counter to be updated
 * 
 * Return:
 *	True if a flit was sent, false if the flit was not sent
 */
bool Router::validGrantSignal(Request& request, std::queue<uint32_t>& flitFIFO,
		std::string creditString) {

	bool sentFlit = true;

	if (!flitFIFO.empty()) {
		// Get a flit from the FIFO
		uint32_t flit = flitFIFO.front();
		uint32_t flitType = get_flit_type(flit);

		if (flitType == HEADER_FLIT) {
			// LBDR generates the request when a header flit has arrrived
			generateRequest(flit, request);
		}

		if (request != Request::idle) {

			// NORTH
			if ((request == Request::north) && (mCredit_Cnt_S > 0)) {
				mChosenOutputPort = "North";
				mCredit_Cnt_S--;
			}
			// EAST
			else if ((request == Request::east) && (mCredit_Cnt_W > 0)) {
				mChosenOutputPort = "East";
				mCredit_Cnt_W--;
			}
			// WEST
			else if ((request == Request::west) && (mCredit_Cnt_E > 0)) {
				mChosenOutputPort = "West";
				mCredit_Cnt_E--;
			}
			// SOUTH
			else if ((request == Request::south) && (mCredit_Cnt_N > 0)) {
				mChosenOutputPort = "South";
				mCredit_Cnt_N--;
			}
			// LOCAL
			else if ((request == Request::local)) {
				mChosenOutputPort = "Local";
			} else {
				sentFlit = false; // FLit could not be sent this time
			}

			if (sentFlit) {
				mNextFlit = flit;
				mCreditCntSignal = creditString;

				// If Tail Flit was sent reset all requests
				if (flitType == TAIL_FLIT) {
					if (request == Request::north) {
						north_grant = false;
					} else if (request == Request::east) {
						east_grant = false;
					} else if (request == Request::west) {
						west_grant = false;
					} else if (request == Request::south) {
						south_grant = false;
					} else if (request == Request::local) {
						local_grant = false;
					}
				}

				// If flit was sent, erase it from the buffer
				flitFIFO.pop();
			}
		} else {
			// Router is IDLE, because other routers block the outputs
			sentFlit = false;
		}
	} else {
		// FIFO is empty
		sentFlit = false;
	}

	return sentFlit;
}

/*
 * Implements the routing logic (LBDR). Generates a request for the output where the packet 
 * needs to be sent based on the source and destination data found in the header flit.
 * 
 * Parameters:
 * 	uint32_t flit: header flit to be processed.
 * 	Router::Request& request: Reference to the request enum used for storing the request
 */
void Router::generateRequest(uint32_t flit, Request& request) {

	uint8_t parity = 0; // TODO: not actually checked, but needed for receiving the flits
	uint16_t srcAddr = 0;
	uint16_t dstAddr = 0;
	bool n1 = false, e1 = false, w1 = false, s1 = false;
	parse_header_flit(flit, &dstAddr, &srcAddr, &parity);

	// Calculate X and Y components of the destination and current addresses.
	uint16_t des_addr_x = dstAddr % mNocSize;
	uint16_t cur_addr_x = mCurrentAddr % mNocSize;
	uint16_t des_addr_y = dstAddr / mNocSize;
	uint16_t cur_addr_y = mCurrentAddr / mNocSize;

	// LBDR logic starts here
	// For additional documentation about LBDR please refer to:
	// https://github.com/Project-Bonfire/Bonfire/wiki/LBDR-(for-routing-computation)
	if (des_addr_y < cur_addr_y) {
		n1 = true;
	}
	if (cur_addr_x < des_addr_x) {
		e1 = true;
	}
	if (des_addr_x < cur_addr_x) {
		w1 = true;
	}
	if (cur_addr_y < des_addr_y) {
		s1 = true;
	}

	// Check if output is already used. If the output is not blocked (grant set to 1), a request is generated.
	if (((n1 && !e1 && !w1) || (n1 && e1 && mRoutingBits[0])
			|| (n1 && w1 && mRoutingBits[1])) && mConnectivityBits[0]
			&& (!north_grant)) {
		// Req_N
		request = Request::north;
		north_grant = true;
	} else if (((e1 && !n1 && !s1) || (e1 && n1 && mRoutingBits[2])
			|| (e1 && s1 && mRoutingBits[3])) && mConnectivityBits[1]
			&& (!east_grant)) {
		// Req_E
		request = Request::east;
		east_grant = true;
	} else if (((w1 && !n1 && !s1) || (w1 && n1 && mRoutingBits[4])
			|| (w1 && s1 && mRoutingBits[5])) && mConnectivityBits[2]
			&& (!west_grant)) {
		// Req_W
		request = Request::west;
		west_grant = true;
	} else if (((s1 && !e1 && !w1) || (s1 && e1 && mRoutingBits[6])
			|| (s1 && w1 && mRoutingBits[7])) && mConnectivityBits[3]
			&& (!south_grant)) {
		// Req_S
		request = Request::south;
		south_grant = true;
	} else if ((!n1 && !e1 && !w1 && !s1) && (!local_grant)) {
		// Req_L
		request = Request::local;
		local_grant = true;
	} else {
		request = Request::idle;
	}
	// End of LBDR logic
}

/*
 * Increases the north credit counter.
 */
void Router::increaseCreditCntNorth() {
	if (mCredit_Cnt_N < mFifoSize) {
		mCredit_Cnt_N++;
	}
}

/*
 * Increases the north credit counter.
 */
void Router::increaseCreditCntWest() {
	if (mCredit_Cnt_W < mFifoSize) {
		mCredit_Cnt_W++;
	}
}

/*
 * Increases the north credit counter.
 */
void Router::increaseCreditCntEast() {
	if (mCredit_Cnt_E < mFifoSize) {
		mCredit_Cnt_E++;
	}
}

/*
 * Increases the north credit counter.
 */
void Router::increaseCreditCntSouth() {
	if (mCredit_Cnt_S < mFifoSize) {
		mCredit_Cnt_S++;
	}
}

/*
 * Pushes the flit given as the parameter to the local FIFO. This function should be
 * called when there's a flit on the local input line and the flow control mechanism 
 * allows the flit to be latched into the FIFO.
 * 
 * Parameters:
 * 	uint32_t flit:	A flit to be pushed into the FIFO
 * 
 * Returns:
 * 	'true' if the FIFO is not full, 'false' otherwise
 */
bool Router::pushToLocalFIFO(uint32_t flit) {
	if (mFlits_RX_L.empty() || (mFlits_RX_L.size() < mFifoSize)) {
		mFlits_RX_L.push(flit);
		return true;
	}
	return false;
}

/*
 * Pushes the flit given as the parameter to the north FIFO. This function should be
 * called when there's a flit on the north input line and the flow control mechanism 
 * allows the flit to be latched into the FIFO.
 * 
 * Parameters:
 * 	uint32_t flit:	A flit to be pushed into the FIFO
 * 
 * Returns:
 * 	'true' if the FIFO is not full, 'false' otherwise
 */
bool Router::pushToNorthFIFO(uint32_t flit) {
	if (mFlits_RX_N.empty() || (mFlits_RX_N.size() < mFifoSize)) {
		mFlits_RX_N.push(flit);
		return true;
	}
	return false;
}

/*
 * Pushes the flit given as the parameter to the east FIFO. This function should be
 * called when there's a flit on the east input line and the flow control mechanism 
 * allows the flit to be latched into the FIFO.
 * 
 * Parameters:
 * 	uint32_t flit:	A flit to be pushed into the FIFO
 * 
 * Returns:
 * 	'true' if the FIFO is not full, 'false' otherwise
 */
bool Router::pushToEastFIFO(uint32_t flit) {
	if (mFlits_RX_E.empty() || (mFlits_RX_E.size() < mFifoSize)) {
		mFlits_RX_E.push(flit);
		return true;
	}
	return false;
}

/*
 * Pushes the flit given as the parameter to the west FIFO. This function should be
 * called when there's a flit on the west input line and the flow control mechanism 
 * allows the flit to be latched into the FIFO.
 * 
 * Parameters:
 * 	uint32_t flit:	A flit to be pushed into the FIFO
 * 
 * Returns:
 * 	'true' if the FIFO is not full, 'false' otherwise
 */
bool Router::pushToWestFIFO(uint32_t flit) {
	if (mFlits_RX_W.empty() || (mFlits_RX_W.size() < mFifoSize)) {
		mFlits_RX_W.push(flit);
		return true;
	}
	return false;
}

/*
 * Pushes the flit given as the parameter to the south FIFO. This function should be
 * called when there's a flit on the south input line and the flow control mechanism 
 * allows the flit to be latched into the FIFO.
 * 
 * Parameters:
 * 	uint32_t flit:	A flit to be pushed into the FIFO
 * 
 * Returns:
 * 	'true' if the FIFO is not full, 'false' otherwise
 */
bool Router::pushToSouthFIFO(uint32_t flit) {
	if (mFlits_RX_S.empty() || (mFlits_RX_S.size() < mFifoSize)) {
		mFlits_RX_S.push(flit);
		return true;
	}
	return false;
}

